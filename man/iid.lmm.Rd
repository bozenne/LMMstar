% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iid.R
\name{iid.lmm}
\alias{iid.lmm}
\title{Extract the Influence Function From a Linear Mixed Model}
\usage{
\method{iid}{lmm}(
  x,
  effects = "mean",
  p = NULL,
  robust = TRUE,
  type.information = NULL,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
}
\arguments{
\item{x}{a \code{lmm} object.}

\item{effects}{[character] Should the influence function for all coefficients be output (\code{"all"}),
or only for coefficients relative to the mean (\code{"mean"} or \code{"fixed"}),
or only for coefficients relative to the variance structure (\code{"variance"}),
or only for coefficients relative to the correlation structure (\code{"correlation"}).
Can also contain \code{"gradient"} to also output the gradient of the influence function.}

\item{p}{[numeric vector] value of the model coefficients at which to evaluate the influence function. Only relevant if differs from the fitted values.}

\item{robust}{[logical] If \code{FALSE} the influence function is rescaled to match the model-based standard errors.
The correlation however will not (necessarily) match the model-based correlation.}

\item{type.information}{[character] Should the expected information be used  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).}

\item{transform.sigma}{[character] Transformation used on the variance coefficient for the reference level. One of \code{"none"}, \code{"log"}, \code{"square"}, \code{"logsquare"} - see details.}

\item{transform.k}{[character] Transformation used on the variance coefficients relative to the other levels. One of \code{"none"}, \code{"log"}, \code{"square"}, \code{"logsquare"}, \code{"sd"}, \code{"logsd"}, \code{"var"}, \code{"logvar"} - see details.}

\item{transform.rho}{[character] Transformation used on the correlation coefficients. One of \code{"none"}, \code{"atanh"}, \code{"cov"} - see details.}

\item{transform.names}{[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?}

\item{...}{Not used. For compatibility with the generic method.}
}
\value{
A matrix with one row per observation and one column per parameter. \itemize{
\item \code{df=TRUE}: with an attribute \code{"df"} containing a numeric vector with one element per parameter. \cr
\item \code{effects} includes \code{"gradient"}: with an attribute \code{"gradient"} containing a 3 dimensional array with dimension the number of parameters.
}
}
\description{
Extract the influence function for an ML or REML estimator of parameters from a linear mixed model.
}
\details{
The influence function equals the individual score rescaled by the (inverse) information.
With the expected information and for a lmm fitted using ML, the information is block diagonal so the influence function for the mean and variance parameters can be computed separately.
Otherwise the information and individual score relative to all model parameters should be considered.
The later is probablematic when using REML as the REML term is the ratio of two term linear in the individual contributions which is not itself linear in the individual contributions.
As an add-hoc solution, the denominator is treated as fixed so the ratio is decomposed w.r.t. its numerator.
}
\examples{
data(gastricbypassL)

if(require(lava)){

#### ML version ####
e.lmmML <- lmm(glucagonAUC ~ visit + weight, method.fit = "ML", df = TRUE,
              repetition = ~ visit|id, data = gastricbypassL)

## linearisation of the estimator
myiid <- iid(e.lmmML)
myiid

## same as
myscore <- score(e.lmmML, indiv = TRUE, effects = "all")
myvcov <- vcov(e.lmmML, effects = "all")
range(iid(e.lmmML) - myscore \%*\% myvcov[,colnames(myiid)])

#### REML version ####
e.lmmREML <- lmm(glucagonAUC ~ visit + weight, method.fit = "REML", df = TRUE,
              repetition = ~ visit|id, data = gastricbypassL)

## linearisation of the estimator
myiid2 <- iid(e.lmmREML)
myiid2

## same as
myscore2 <- score(e.lmmREML, indiv = TRUE, effects = "all")
myvcov2 <- vcov(e.lmmREML, effects = "all")
range(iid(e.lmmREML) - myscore2 \%*\% myvcov2[,colnames(myiid2)])

## NOTE: the score w.r.t. the variance-covariance parameters
##       is not a sum of individual contributions with REML
## due to a term that looks like tr(\sum_i A_i / \sum_i B_i)
## the individual contribution is taken to be tr(A_i / \sum_i B_i)


}
}
\keyword{methods}
